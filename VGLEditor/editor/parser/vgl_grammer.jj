/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. vgl_grammer.jj */
/*@egen*/ /**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
               
  STATIC = false;
  IGNORE_CASE = true;
  COMMON_TOKEN_ACTION = true; //calls commonTokenAction after creating token
  TOKEN_MANAGER_USES_PARSER = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
                                                              
                          
                         
                          
}

PARSER_BEGIN(VGLParser)
package editor.parser;

public class VGLParser extends VGLParserBase/*@bgen(jjtree)*/implements VGLParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTVGLParserState jjtree = new JJTVGLParserState();

/*@egen*/}

PARSER_END(VGLParser)

//  =================================================================
//  Define the token manager.
//  =================================================================
TOKEN_MGR_DECLS :
{
  void CommonTokenAction(Token t)
  {
  }
}

SKIP :
{
  " "
| "\t"
  //| "\n"
  //| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      ~[ "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL : < DECIMAL_LITERAL > >
| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
}

TOKEN : /* Commands */
//This declaration must be before identifier, else thse tokens will
//be recognized as identifiers
{
  < CANVAS : "CANVAS" >
| < POINT : "POINT" >
| < LINE : "LINE" >
| < CIRCLE : "CIRCLE" >
| < BUTTON : "BUTTON" >
| < ROTATE : "ROTATE" >
| < MESSAGE : "MESSAGE" >
| < FUNCTION : "FUNCTION" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < STR_LITERAL : 
    "\"" 
    ~[ "\n", "\r" ] 
    "\"" 
    >
| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
}

TOKEN :
{
  < EOL :
    "\r\n"
  | "\r"
  | "\n" >
}

SimpleNode Start() :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  (
    CommandStatement()
  | 
    FunctionDef()
  )*
  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void CommandStatement()       :
{}
{
  Command()
  (
    (
      < EOL >
    )+
  | 
    < EOF >
  )
}

void Command()       :
{}
{
  Canvas()
| Point()
| Line()
| Circle()
| FunctionCall()
}

void Point() :
{/*@bgen(jjtree) Point */
  ASTPoint jjtn000 = new ASTPoint(this, JJTPOINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Point */
  try {
/*@egen*/
  < POINT > < INTEGER_LITERAL > < INTEGER_LITERAL > Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Canvas() :
{/*@bgen(jjtree) Canvas */
  ASTCanvas jjtn000 = new ASTCanvas(this, JJTCANVAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Canvas */
  try {
/*@egen*/
  < CANVAS > < INTEGER_LITERAL > < INTEGER_LITERAL >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Circle() :
{/*@bgen(jjtree) Circle */
  ASTCircle jjtn000 = new ASTCircle(this, JJTCIRCLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Circle */
  try {
/*@egen*/
  < CIRCLE > Numeric() Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Line() :
{/*@bgen(jjtree) Line */
  ASTLine jjtn000 = new ASTLine(this, JJTLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Line */
  try {
/*@egen*/
  < LINE >
  (
    LOOKAHEAD(3)
    (
      Identifier() Identifier() Identifier()
    )
  |
    (
      Identifier() Identifier()
    )
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Button() :
{/*@bgen(jjtree) Button */
  ASTButton jjtn000 = new ASTButton(this, JJTBUTTON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Button */
  try {
/*@egen*/
  < BUTTON > 
  < INTEGER_LITERAL > < INTEGER_LITERAL > < STR_LITERAL > Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FunctionCall() :
{/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(this, JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) FunctionCall */
  try {
/*@egen*/
  Identifier() "()"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FunctionDef() :
{/*@bgen(jjtree) FunctionDef */
  ASTFunctionDef jjtn000 = new ASTFunctionDef(this, JJTFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) FunctionDef */
  try {
/*@egen*/
  < FUNCTION > Identifier()
  (
    < EOL >
  )+
  "{"
  (
    < EOL >
  )+
  (
    Command()
    (
      < EOL >
    )+
  )*
  "}"
  (
    < EOL >
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  < IDENTIFIER >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FloatNumeric()       :
{}
{
  [ < INTEGER_LITERAL > ] "." < INTEGER_LITERAL >
}

void Numeric()       :
{}
{
  LOOKAHEAD(2)
  < INTEGER_LITERAL >
| 
  FloatNumeric()
}
